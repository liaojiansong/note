## redis 须知
### 缓存的几种事故
前提:请求量巨大
#### 缓存穿透
##### 定义
访问一个根本不存在的key(例如id为负数),这个时候请求就会跑到数据库中,造成数据库压力
##### 解决方案
1. 采用布隆过滤器
2. 即使是空值,也一样写进缓存中,并设置一个较短的过期时间
3. 判断key的合理性,例如负数一律打死

#### 缓存雪崩
##### 定义
大量的key在同一时间内集体失效又或者说缓存系统突然宕机,请求集中跑到数据库中. 
##### 解决方案
1. 避免key过期时间过于集中,交错散布
2. 采用缓存集群系统加哨兵模式,迅速换掉挂了的机器
3. 采用持久化,尽快从磁盘中回复数据
4. 限流处理,进行服务降级


#### 缓存击穿
##### 定义
某一个热点key突然间失效,导致大量请求跑到数据库中
##### 解决方案
1. 将热点数据设置为永不过期,编码管控
2. 利用SETNX互斥锁(SETNX 是SET if Not Exists的简写)



### SETNX
SETNX 是SET if Not Exists的简写,判断一个key如果不存在,就为这个key 设定一个值.假如key已经存在,将无法再给这个key设定值
#### 作用
可以利用SETNX做一个互斥锁,只有当你获得这个锁的时候才能去更新缓存,而其他的请求只能等待. 不过要注意死锁的问题(利用时间判断解决如:时间戳-占用秒数)



### 关于事务
#### 几个关键命令
1. `multi` 开启一个事务
2. `discard` 强制取消一个事务
3. `exec` 执行事务

### 事务的基本原理
当用户开启事务后,会将后续的命令放进队列中,当遇到 `exec` 命令时候,依次执行队列中的命令,其中有几种情况会导致事务回滚
1. 用户显示调用 `discard` 命令中断事务
2. 用户调用不存在的命令导致的语法错误会中断事务

* 特别注意的是,用户对类型的错误操作不会使得事务回滚
例如下面的代码,用户错误的对字符串类型进行了自增操作,但是错误语句之前和之后的命令还是成功执行了

```shell script
127.0.0.1:6379> multi                                  
OK                                                     
127.0.0.1:6379> set name jason                         
QUEUED                                                 
127.0.0.1:6379> set girls 10                           
QUEUED                                                 
127.0.0.1:6379> incr name                              
QUEUED                                                 
127.0.0.1:6379> set age 18                             
QUEUED                                                 
127.0.0.1:6379> exec                                   
1) OK                                                  
2) OK                                                  
3) (error) ERR value is not an integer or out of range 
4) OK                                                  
```